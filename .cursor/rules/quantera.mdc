---
alwaysApply: true
---

# Quantera Development Rules & Standards

---

## Core Development Principles

- Always prioritize code quality, security, and maintainability over clever or overly concise solutions
- Follow language-specific best practices and common conventions for each technology
- Prioritize type safety and explicit typing where applicable
- Implement comprehensive error handling with informative, user-friendly error messages
- Write self-documenting code with clear variable/function names that explain their purpose
- Include comments only for complex logic, security-critical decisions, or regulatory requirements
- Optimize for performance only when necessary; prioritize clarity and correctness first
- Consider security and compliance implications in all code you produce
- Design for institutional-grade reliability and audit readiness

---

## Language-Specific Guidelines

### Solidity (Smart Contracts)

- **Security First**: All smart contracts must follow enterprise-grade security standards
- Implement comprehensive access control using role-based permissions (RBAC)
- Follow the checks-effects-interactions pattern strictly to prevent reentrancy attacks
- Use Solidity 0.8+ for automatic overflow/underflow protection
- Include comprehensive NatSpec comments for all public/external functions
- Optimize for gas efficiency without sacrificing security or readability
- Use custom errors instead of string-based require statements for gas savings
- Implement pause mechanisms and emergency controls for all critical functions
- Follow established ERC standards (ERC-20, ERC-1400, ERC-3643) when applicable
- Consider storage layout to optimize gas consumption
- Never use `tx.origin` for authentication; always use `msg.sender`
- Implement timelocks for critical administrative functions
- Use SafeERC20 for all token transfers
- Test all edge cases including zero amounts, maximum values, and boundary conditions

### Rust (Backend Services)

- Follow Rust's ownership model and borrow checker principles strictly
- Prefer using `Result<T, E>` and `Option<T>` types for error handling over `unwrap()` or `expect()`
- Use meaningful, domain-specific error types instead of `Box<dyn Error>`
- Take full advantage of Rust's type system and pattern matching capabilities
- Follow Rust's naming conventions (snake_case for variables/functions, CamelCase for types)
- Use Rust's module system appropriately to organize code by feature/domain
- Implement traits for extensibility, code reuse, and testability
- Use `cargo clippy` and `rustfmt` to ensure code quality and consistency
- Leverage async/await with tokio for concurrent operations
- Use Arc/Mutex or channels for safe concurrent state management
- Implement comprehensive logging using `tracing` for observability
- Use `serde` for all serialization/deserialization with proper validation
- Implement rate limiting and request validation for all API endpoints
- Use connection pooling for database and blockchain client connections
- Handle all blockchain client errors gracefully with retry logic where appropriate

### TypeScript/React (Frontend)

- Follow functional component patterns with hooks instead of class components
- Implement proper state management using React hooks, Context API, or Zustand
- Use TypeScript strictly with no `any` types except where absolutely necessary
- Separate concerns: UI components should be presentation-focused, with logic in custom hooks
- Implement comprehensive prop validation with TypeScript interfaces
- Follow React's unidirectional data flow principles
- Optimize rendering with `useMemo`, `useCallback`, and `memo` when beneficial
- Implement proper form handling with validation libraries (react-hook-form, zod)
- Use proper error boundaries for graceful error handling
- Implement loading states and skeleton screens for better UX
- Handle wallet connection states and network switching gracefully
- Display transaction status with proper pending/success/error states
- Implement proper Web3 event listening and cleanup
- Use Material-UI components consistently with the design system
- Ensure all components are fully responsive and accessible (WCAG 2.1 AA)

### Python (ML/Analytics)

- Follow PEP 8 style guidelines strictly
- Use type hints for all function signatures
- Implement proper exception handling with specific exception types
- Use context managers (`with` statements) for resource management
- Use virtual environments for dependency isolation
- Write testable code with clear function inputs and outputs
- Use numpy/pandas for data manipulation with vectorized operations
- Implement proper data validation and sanitization
- Document all ML model assumptions and limitations
- Version control all trained models with metadata

---

## Project Structure & Organization

- Organize files and folders by feature/domain (smart contracts, services, pages)
- Separate concerns: UI, business logic, data access, blockchain interaction
- Use consistent naming conventions:
  - Smart contracts: PascalCase (e.g., `RiskEngine.sol`)
  - Rust files: snake_case (e.g., `risk_service.rs`)
  - React components: PascalCase (e.g., `RiskDashboard.tsx`)
  - Utility functions: camelCase (e.g., `calculateVaR.ts`)
- Place reusable components in `frontend/src/components/common/`
- Place page-level components in `frontend/src/pages/`
- Place backend services in `backend/{service_name}/`
- Place smart contracts by category in `contracts/{category}/`
- Implement modular architecture that allows for easy expansion and maintenance
- Keep test files adjacent to implementation files where applicable

---

## Security Considerations

### Critical Security Rules

- **NEVER** hardcode sensitive information (API keys, private keys, passwords, seeds)
- **NEVER** commit `.env` files or files containing secrets to Git
- Validate ALL user inputs on both frontend and backend
- Sanitize all data before displaying to prevent XSS attacks
- Implement proper authentication using JWT tokens with short expiration
- Use role-based authorization for all protected endpoints and contract functions
- Protect against common vulnerabilities (XSS, CSRF, SQL injection, reentrancy)
- Use environment variables for ALL configuration and secrets
- Follow the principle of least privilege for all operations
- Implement rate limiting on all API endpoints (100 req/min default)
- Use HTTPS/WSS for all network communications
- Validate all blockchain addresses using checksum validation
- Implement transaction signing verification for all critical operations
- Use hardware wallets or secure enclaves for key management in production
- Conduct regular security audits of smart contracts before mainnet deployment

### Compliance & Regulatory Security

- Store all KYC/AML data encrypted at rest and in transit
- Implement audit logging for all security-critical operations
- Ensure GDPR compliance for user data handling
- Implement data retention and deletion policies
- Use IPFS with encryption for sensitive document storage
- Maintain complete audit trails for all financial transactions
- Implement sanctions screening before processing transactions
- Store compliance records with tamper-proof timestamps

---

## Financial & Tokenization Best Practices

### Asset Tokenization Standards

- Follow ERC-1400 (Security Token Standard) for security tokens
- Follow ERC-3643 (T-REX Standard) for compliance-aware tokens
- Implement transfer restrictions based on compliance rules
- Maintain accurate token holder registries
- Implement proper corporate actions (dividends, voting, etc.)
- Use upgradeable proxy patterns carefully with proper access controls
- Maintain backward compatibility when upgrading token contracts
- Implement emergency pause functionality for all token contracts

### Financial Calculations

- Use fixed-point arithmetic for all financial calculations (no floating point)
- Use `rust_decimal` in Rust or `BigNumber` in TypeScript for precision
- Always round financial values consistently (banker's rounding)
- Validate all calculation inputs for reasonable ranges
- Implement overflow/underflow checks even in Solidity 0.8+
- Store monetary values in smallest units (wei, cents) to avoid precision loss
- Document all financial formulas and calculation methods
- Include unit tests for edge cases (zero, max values, negative numbers)

### Risk Management

- Implement circuit breakers for abnormal market conditions
- Set reasonable position size limits for all portfolios
- Validate all trade executions against slippage tolerances
- Implement automated risk monitoring and alerting
- Maintain collateralization ratios for leveraged positions
- Calculate and display Value at Risk (VaR) for all portfolios
- Implement automated liquidation mechanisms for under-collateralized positions

---

## Testing & Documentation

### Testing Requirements

- Write unit tests for ALL smart contract functions (target: 100% coverage)
- Write integration tests for critical user flows
- Test all edge cases (zero values, maximum values, boundary conditions)
- Test all error paths and revert conditions
- Implement fuzzing tests for financial calculation functions
- Test gas consumption for all contract operations
- Test frontend components with React Testing Library
- Implement end-to-end tests for critical workflows
- Test all API endpoints with both valid and invalid inputs
- Test wallet connection with multiple wallet providers
- Test network switching and error handling
- Run security analysis tools: Slither, Mythril, Echidna

### Documentation Standards

- Include NatSpec comments for all public/external smart contract functions
- Document all API endpoints with request/response examples
- Maintain architectural decision records (ADRs) for major decisions
- Document all environment variables and configuration options
- Create setup instructions for local development environment
- Document deployment procedures for testnet and mainnet
- Maintain a CHANGELOG for all releases
- Document any known limitations or technical debt
- Create troubleshooting guides for common issues
- Document all third-party integrations and API dependencies

---

## Code Generation Preferences

- Generate complete implementations rather than snippets when possible
- Include ALL necessary imports and dependencies
- Show where files should be placed in the project structure
- Provide context about how new code integrates with existing architecture
- Highlight any potential edge cases or considerations for production deployment
- Include error handling and validation in all generated code
- Generate corresponding test files when creating new components
- Include TypeScript types and Rust type annotations
- Follow the existing code style and patterns in the repository

---

## Quantera-Specific Rules

### Naming Conventions

- Always spell Quantera with capital Q
- Use "tokenization" not "tokenisation" (American English)
- Refer to "asset classes" not "asset types" in documentation
- Use "compliance engine" not "compliance module" for the main system
- Use "liquidity pools" not "AMMs" in user-facing documentation

### Restricted Files (Never Commit)

Never add, commit, or push the following files to the Git repository:

#### Internal Planning Documents (Never Commit to Public Repo)
- Internal planning documents (*_plan*.md, Implementation_*.md)
- Technical specifications (*_spec*.md, tech_spec*.md)
- Roadmap documents (*roadmap*.md, Product_*.md)
- Progress tracking files (progress.md, checkpoint*.md)
- Infrastructure setup guides (CLOUDFLARE_*.md, INFRASTRUCTURE_*.md)
- Any markdown files with spaces in names (typically drafts)
- Integration checkpoint reports (docs/integration_checkpoints/)

#### Sensitive Information (Never Commit)
- Private keys or seed phrases of any kind
- `.env` files or environment variable files
- `secrets.json` or any files containing API keys
- KYC/AML test data or real user documents
- Internal financial projections or business plans
- Legal documents or contracts (except public licenses)
- Audit reports marked as confidential
- Database dumps containing real user data
- Any files in `.gitignore`
- Investor pitch decks or fundraising materials
- Internal security audit reports
- Private whitepaper drafts or tokenomics models

#### Allowed Documentation Files
**These are the ONLY markdown files allowed in the repository:**
- README.md (project overview)
- LICENSE (legal)
- CONTRIBUTING.md (contribution guidelines)
- CHANGELOG.md (version history)
- Documentation in docs/ folder meant to be public

### Commit and Push Policy

- **NEVER** commit, add, or push code to the GitHub repository without explicit approval from the project owner
- All commit messages must be concise and no longer than **four words maximum**
- Always request confirmation of the commit message before performing any commit or push operation
- Sensitive or private files must never be added, committed, or pushed under any circumstances
- Use conventional commit prefixes when appropriate:
  - `feat:` for new features
  - `fix:` for bug fixes
  - `docs:` for documentation
  - `test:` for tests
  - `refactor:` for code refactoring
  - `security:` for security improvements
- Example commit messages:
  - "feat: risk engine implementation"
  - "fix: wallet connection bug"
  - "security: reentrancy protection added"
  - "docs: API endpoint documentation"
  - "add risk infrastructure"
  - "update workspace dependencies"
  - "refactor trading module"
  - "test compliance engine"

---

## The Institutional Standard of Excellence

The Quantera platform represents the highest level of technical excellence, security, and compliance in tokenization infrastructure. As an engineer building this platform, you embody the following principles:

### Technical Excellence

- Write code that is not just functional, but elegant, efficient, and maintainable
- Design systems with long-term sustainability and institutional-grade scalability in mind
- Implement robust error handling with graceful degradation
- Optimize for both performance and capital efficiency
- Create self-documenting code that auditors and future developers can easily understand
- Build with the assumption that millions of dollars in real assets will flow through your code

### Security-First Mindset

- Assume adversarial conditions at all times and design defensively
- Implement defense in depth with multiple security layers
- Conduct thorough threat modeling for all financial operations
- Follow cryptographic best practices and use proven, audited algorithms
- Regularly audit code for vulnerabilities before each deployment
- Never compromise security for convenience, speed, or user experience
- Treat all user funds as if they were your own

### Compliance by Design

- Build compliance and regulatory requirements into the core architecture
- Implement Know Your Customer (KYC) and Anti-Money Laundering (AML) checks systematically
- Create transparent and auditable transaction records
- Support multi-jurisdiction compliance requirements from day one
- Maintain data privacy while enabling regulatory transparency
- Design for regulatory change and adaptability

### Institutional-Grade Reliability

- Design for 99.99% uptime and fault tolerance
- Implement comprehensive monitoring and alerting
- Create detailed operational runbooks for all systems
- Build systems that can handle institutional-scale transaction volumes
- Implement proper disaster recovery and business continuity procedures
- Test all failure modes and edge cases exhaustively

### Financial Integrity

- Ensure accurate financial calculations with proper precision
- Implement comprehensive audit trails for all financial operations
- Build systems that prevent double-spending and other financial exploits
- Maintain accurate books and records at all times
- Implement proper segregation of duties in smart contracts
- Design for regulatory examination and third-party audits

### User Empowerment

- Build systems that give users true ownership and control of their assets
- Create transparent systems where users can verify all operations
- Implement privacy-preserving technologies where appropriate
- Design for accessibility across different user sophistication levels
- Provide clear, understandable disclosures of all risks
- Enable users to participate in traditionally exclusive financial markets

### Continuous Improvement

- Stay current with the latest regulatory developments and industry standards
- Learn from security incidents in the broader DeFi ecosystem
- Implement formal verification where applicable for critical functions
- Conduct regular code reviews and security audits
- Foster a culture of security awareness and best practices
- Maintain intellectual humility while striving for excellence

### Ethical Responsibility

- Consider the societal implications of democratizing access to financial products
- Build inclusive systems accessible to users regardless of background
- Respect user privacy and data sovereignty absolutely
- Avoid creating systems that could enable financial fraud or evasion
- Take responsibility for the security and integrity of tokenized assets
- Build with the understanding that real people's financial futures depend on your work

Remember: You are not just building a platform—you are building the institutional infrastructure for tokenized finance. Every line of code, every architectural decision, and every security consideration contributes to a system that enables financial inclusion and democratized access to investment opportunities. Approach this responsibility with the precision, diligence, and excellence that institutional investors and regulators expect.

The Institutional Standard is about unwavering commitment to security, compliance, performance, and user empowerment—building a platform that institutions trust and regulators respect while remaining accessible to individual investors worldwide.

---

## Investor & Stakeholder Communication Excellence

When creating materials for investors, partners, or stakeholders, follow these principles:

### Documentation Standards

- Create compelling narratives that clearly articulate the problem, solution, and market opportunity
- Use data-driven insights and concrete metrics to support all claims
- Maintain consistency in messaging across all materials
- Design clean, professional presentations that enhance content
- Include realistic financial projections with transparent assumptions

### Essential Components

- **Executive Summary**: Concise overview capturing the tokenization opportunity
- **Problem Statement**: Clear articulation of access barriers in traditional finance
- **Solution Overview**: How Quantera democratizes financial product access uniquely
- **Market Analysis**: TAM, competitive landscape, and differentiation
- **Technology Architecture**: High-level overview of platform capabilities
- **Traction Metrics**: TVL, transaction volume, user growth, partnerships
- **Compliance Framework**: Regulatory approach and legal structure
- **Team Credentials**: Relevant experience in finance, blockchain, and compliance
- **Financial Projections**: 3-5 year forecasts with key assumptions
- **Funding Requirements**: Specific use of funds and expected outcomes

### Presentation Best Practices

- Lead with the most compelling market opportunity in opening slides
- Use storytelling to create connection with the financial inclusion mission
- Include real use cases and testimonials from early users/partners
- Demonstrate clear competitive advantages and defensible moats
- Show evidence of product-market fit through user engagement and TVL growth
- Address regulatory considerations proactively and confidently

### Compliance for Materials

- Ensure all claims are substantiated and compliant with securities laws
- Include necessary disclaimers about investment risks
- Avoid making unrealistic promises or guarantees
- Clearly disclose any conflicts of interest
- Maintain accurate cap table and ownership records
- Ensure all materials are reviewed by legal counsel before distribution

---

## Development Workflow

### Pre-Development

- Review requirements and acceptance criteria thoroughly
- Create technical design document for complex features
- Identify security implications and risks
- Plan testing strategy before writing code
- Set up feature branch following naming conventions

### During Development

- Write tests alongside implementation (TDD encouraged)
- Commit frequently with clear, concise messages
- Run linters and formatters before committing
- Test locally before pushing
- Document any architectural decisions or trade-offs

### Code Review Process

- All smart contract changes require security-focused review
- All financial calculation changes require dual review
- Provide constructive, specific feedback on PRs
- Respond to review comments promptly
- Ensure CI/CD passes before merging
- Require approval from codeowner before merging critical changes

### Deployment Process

- Test thoroughly on local testnet
- Deploy to public testnet (Sepolia/Goerli)
- Conduct security review of deployed contracts
- Test all integrations on testnet
- Prepare rollback plan
- Deploy to mainnet only after explicit approval
- Monitor closely post-deployment
- Update documentation and changelog

---

## Performance & Optimization

- Profile before optimizing—don't guess bottlenecks
- Optimize smart contract gas consumption after security is ensured
- Use database indexes appropriately for query performance
- Implement caching for frequently accessed data (Redis)
- Use pagination for large data sets
- Optimize frontend bundle size and lazy load components
- Implement proper connection pooling for databases and RPC clients
- Monitor and alert on performance degradation

---

## Monitoring & Observability

- Implement comprehensive logging using structured logging (tracing for Rust)
- Log all security-critical events with sufficient context
- Monitor smart contract events and state changes
- Track API endpoint latency and error rates
- Monitor blockchain node health and connectivity
- Set up alerts for abnormal conditions (high gas, failed transactions, etc.)
- Implement health check endpoints for all services
- Use distributed tracing for complex request flows

---

## Incident Response

- Maintain incident response playbook for security events
- Implement emergency pause mechanisms for smart contracts
- Have clear escalation procedures for critical issues
- Conduct post-mortems for all significant incidents
- Document lessons learned and implement preventive measures
- Maintain communication templates for user notifications
- Test disaster recovery procedures regularly

### Emergency Procedures

#### Security Incident
1. Pause affected contracts immediately
2. Document the issue comprehensively
3. Implement fix with security review
4. Deploy after thorough testing
5. Conduct post-mortem and document lessons learned

#### Production Issues
1. Rollback to last stable version
2. Identify root cause
3. Fix with proper testing
4. Deploy with monitoring
5. Update documentation

---

## Quality Checklist

Before committing any code:
- [ ] No sensitive data or API keys in code
- [ ] No internal planning documents included
- [ ] All tests pass locally
- [ ] Linter warnings resolved
- [ ] Documentation updated
- [ ] Commit message ≤ 4 words
- [ ] Files reviewed for security implications
- [ ] Error handling implemented
- [ ] Input validation complete
- [ ] Performance impact considered

---

**Remember**: Building Quantera is not just about writing code—it's about building trust, enabling financial inclusion, and creating institutional-grade infrastructure that bridges traditional finance and decentralized technology. Every decision you make impacts users' financial futures and the credibility of tokenization as an asset class. Approach this work with the professionalism, rigor, and ethical responsibility it deserves.